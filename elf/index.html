<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Elf: Elf (Evolutionary Language Framework) Documentation [0.5]</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>ELF (The Evolutionary Language Framework) v0.5 </h1>
<img src="Images/Logo.png" style="display:block; width:100px; margin: 0 auto;"></div>
</div>
<div class="contents">
<h2>What is Elf?</h2>
<p>Elf is a meta-language framework for genetic programming. First, Elf provides the infrastructure and basic commands necessary for defining a <em>language</em>, or instruction set, with which to evolve solutions to any algorithmic challenge. Solutions are themselves simple (or complex) programs built from these simple assembly-esque languages. Second, Elf provides tools for generating and improving (via evolution by mutation and selection) candidate solutions to any problem the user may dream up.</p>
<h2><a class="anchor" id="installation"></a>
Installing Elf</h2>
<p>Elf is written in C++ and so requires a C++ compiler (i.e. GCC) to build. Besides this though, Elf comes with a completely self-contained build-system. Its only dependencies are CMake (for generating makefiles), TinyXML and Doxygen (for documentation only), and all three are packaged with the source distribution.</p>
<p><b>Mac OS X Build Instructions:</b></p>
<ol type="1">
<li>Open a terminal window and <code>cd</code> to the source directory.</li>
<li>Type <code> ./Build-CMake -G Xcode </code></li>
<li>Open <code>build/Elf.xcode</code> and build the project.</li>
</ol>
<h2><a class="anchor" id="scenario"></a>
A Day in the Life of Elf</h2>
<p><b>Note:</b> This is a terribly contrived example and would be much more efficiently written by hand in 5 lines of code. The point is to introduce you to the life-cycle of an Elf program and give an overview of each stage involved.</p>
<p>Imagine Jane wants to evolve a controller for a simple robot. This robot is very unstable and, when left to its own devices, will fall over. For the sake of simplicity, say the robot has five states: -2 (fallen left), -1 (falling left), 0 (temporarily stable), 1 (falling right), 2 (fallen right). The successful robot controller should:</p>
<ol type="1">
<li>Beep for attention if the robot has fallen over (either to the left or right).</li>
<li>Move left to stabilize itself if it is falling left.</li>
<li>Move right to stabilize itself if it is falling right.</li>
<li>Do nothing if it is stable.</li>
</ol>
<p>Before anything, remember to include the Elf header files: </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;ELF/ELF.h&gt;</span>
<span class="keyword">using namespace </span>ELF;
</pre></div><h3><a class="anchor" id="language"></a>
Defining the Language</h3>
<p>The first order of business is to define a Language for these controllers. A <code>Language</code> describes the commands candidate solutions can use as well as the mutations by which they are generated and modified. </p>
<div class="fragment"><pre class="fragment">    <span class="comment">// Create the language</span>
    Language* language = <span class="keyword">new</span> Language();
</pre></div><p>The first thing a language needs is Value types. Elf includes basic types like <code>BoolValue</code>, <code>IntValue</code>, <code>FloatValue</code>, <code>StringValue</code>, and more. These are only for convenience, you can just as easily use your own types (see <a class="el" href="d0/d65/definingvaluetypes.html">Defining Value Types</a>). For this example, we only need two real types, integers and booleans. The third, <code>LabelValue</code>, will be discussed later. </p>
<div class="fragment"><pre class="fragment">    <span class="comment">// Define value types</span>
    language-&gt;addValueType&lt;BoolValue&gt;();
    language-&gt;addValueType&lt;IntValue&gt;();
    language-&gt;addValueType&lt;LabelValue&gt;();
</pre></div><p>Second, a language needs at least one <code>Initializer</code> for each <code>Value</code> type. An <code>Initializer</code> is a function (well, technically an Initializer object with a method) that returns a new instance of a particular <code>Value</code> type. For example, a <code>RandomIntInitializer</code> will return a random integer uniformly chosen from the range [min,max] given in its constructor. Since we don't care about the entire number line surrounding [-2,2], the following will suffice: </p>
<div class="fragment"><pre class="fragment">    <span class="comment">// Define value initializers</span>
    language-&gt;addInitializerType(<span class="keyword">new</span> RandomBoolInitializer());
    language-&gt;addInitializerType(<span class="keyword">new</span> RandomIntInitializer(-2,2));
    language-&gt;addInitializerType(<span class="keyword">new</span> LabelInitializer());
</pre></div><p>Third comes the interesting part: defining the <code>Instructions</code> our solutions will have at their disposal. Instructions are the building blocks of Elf programs, and are defined in C++ code. They each accept a number of typed arguments, and return nothing. Since arguments are all passed as <code>Pointers</code>, return values can be emulated by changing the <code>Value</code> a <code>Pointer</code> references.</p>
<p>Since each Instruction is designed to be quite basic, even a simple problem requires a number of them. Here's a description of the ones we will use:</p>
<ul>
<li><code>EqualInt(bool0,int0,int1)</code>: Takes int0 and int1, compares them, and assigns the resulting boolean to bool0.</li>
<li><code>Label(label0)</code>: Labels store a line number, which can later be used to jump to different points in the program using control flow commands. LabelInstructions differ from other commands in one key way: they are all executed before the program starts. Thus, they get to initialize all LabelValues before anything else gets run.</li>
<li><code>Goto(label0)</code>: Jump to label0.</li>
<li><code>Fork(bool0,label0,label1)</code>: Combined with an <code>EqualIntInstruction</code>, a  forms the equivalent of an "if" statement in any other language. If bool0 is true, jump to label0, otherwise jump to label1.</li>
<li><code>GetRobotState(int0)</code>: Assign the robot's current state to int0.</li>
<li><code>MoveRobot(int0)</code>: If int0 is -1, move left, if it's 1, move right, otherwise, do nothing.</li>
<li><code>BeepRobot(bool0)</code>: Make the robot beep iff bool0 is true.</li>
</ul>
<p>Note that unlike the first three, <code>GetRobotStateInstruction</code>, <code>MoveRobotInstruction</code> and <code>BeepRobotInstruction</code> are problem specific Instructions added by the user, though Elf treats them in exactly the same manner as its own <code>Instructions</code>.</p>
<p>Here's the code: </p>
<div class="fragment"><pre class="fragment">    <span class="comment">// Define instructions</span>
    language-&gt;addInstructionType&lt;IntEqualInstruction&gt;();
    language-&gt;addInstructionType&lt;LabelInstruction&gt;();
    language-&gt;addInstructionType&lt;GotoInstruction&gt;();
    language-&gt;addInstructionType&lt;ForkInstruction&gt;();
    language-&gt;addInstructionType&lt;GetRobotStateInstruction&gt;();
    language-&gt;addInstructionType&lt;MoveRobotInstruction&gt;();
    language-&gt;addInstructionType&lt;BeepRobotInstruction&gt;();
</pre></div><p>Fourth, we define the available mutation types and set the MutationScheme to decide how they are applied. <code>addMutationType()</code> takes an optional <code>weight</code> argument which has different meanings depending on the <code>MutationScheme</code>. The <code>RouletteMutationScheme</code>, for example, interprets each as the size of slice on a virtual roulette wheel, and selects one mutation to apply randomly by "spinning" the wheel.</p>
<p>We will use six different mutation types for this example. For now, it is not necessary to understand the details or each, only to note that this is a good set of operators to start with for virtually any problem. The first four alone form the basis for the solution space of all possible programs that can be constructed in our language, while the last three make the space significantly more connected by effectively bridging gaps in the solution space. </p>
<div class="fragment"><pre class="fragment">    <span class="comment">// Configure mutation operation</span>
    MutationScheme* mutater = <span class="keyword">new</span> RouletteMutationScheme(language);
    mutater-&gt;addMutationType&lt;InsertInstructionMutation&gt;(<span class="stringliteral">&quot;InsertInstruction&quot;</span>);
    mutater-&gt;addMutationType&lt;DeleteInstructionMutation&gt;(<span class="stringliteral">&quot;DeleteInstruction&quot;</span>);
    mutater-&gt;addMutationType&lt;AddBinMutation&gt;(<span class="stringliteral">&quot;AddBin&quot;</span>);
    mutater-&gt;addMutationType&lt;RemoveBinMutation&gt;(<span class="stringliteral">&quot;RemoveBin&quot;</span>);
    mutater-&gt;addMutationType&lt;ChangeInitializerMutation&gt;(<span class="stringliteral">&quot;ChangeInitializer&quot;</span>);
    mutater-&gt;addMutationType&lt;ChangeArgumentMutation&gt;(<span class="stringliteral">&quot;ChangeArgument&quot;</span>);
    mutater-&gt;addMutationType&lt;MoveInstructionMutation&gt;(<span class="stringliteral">&quot;MoveInstruction&quot;</span>);
</pre></div><h3><a class="anchor" id="stepback"></a>
Let's step back for a second...</h3>
<p>...and take a look at what we've done. We defined a "language" which solutions to a particular problem can utilize, and a "mutation scheme" by which solutions are generated. Notice that there's no concept of an "individual" yet, no fitness, no selection, no evolution. This is intentional. At this point, if you wanted to go off and implement your own niche environment (pun intended), you can go right ahead while still taking full advantage of the majority of Elf's code base. Like all the other built in types, instructions, and mutations Elf provides, the default environments are only there for convenience.</p>
<h3><a class="anchor" id="environment"></a>
The Environment</h3>
<p>Everybody loves the environment! Hippies love it because it has trees. Businesses pretend to love it because it gets them customers. Politicians because it gets them votes. And Darwin loved it because it has the wonderful property that it's always forcing things to improve. Well, maybe that's not why he loved it, but it is why we do.</p>
<p>The first last thing we need to do to use the default <code>Environments</code> is to define a Problem class that implements the <code>evaluateFunction()</code> method. The <code>Language</code> initialization code we've written goes right in the <code>Problem's</code> constructor, and is retrieved by the <code>Environment</code> using the <code>Probem::getLanguage()</code> method.</p>
<p><b>Note:</b> The way we've set up our robot controllers' intput/output is much more flexible than a simple argument-return paradigm. If, for instance, you're trying to evolve a mathematical function and do want that, however, all you need to do is override the <code>getArgTypes()</code> method.</p>
<p>Assuming we've already written our <code>Robot</code> class (which we clearly have since <code>GetRobotStateInstruction</code>, <code>MoveRobotInstruction</code>, and <code>BeepRobotInstruction</code> already rely on it!), our <code>RobotProblem</code> class would look something like this: </p>
<div class="fragment"><pre class="fragment">    <span class="keyword">class </span>RobotProblem : <span class="keyword">public</span> Problem
    {
    <span class="keyword">public</span>:
        <span class="keyword">struct </span>TestCase
        {
            <span class="keywordtype">int</span> state;
            <span class="keywordtype">int</span> move;
            <span class="keywordtype">bool</span> beep;
            TestCase (<span class="keywordtype">int</span> s, <span class="keywordtype">int</span> m, <span class="keywordtype">bool</span> b) : state(s), move(m), beep(b) {}
        };
        
        <span class="keyword">typedef</span> std::vector&lt;TestCase&gt; TestCases;
        TestCases mTestCases;
        
        RobotProblem ()
        {
            <span class="comment">// Define language</span>
            mLanguage = <span class="keyword">new</span> Language();
            ...
            
            <span class="comment">// Define test case</span>
            mTestCases.push_back(TestCase(-2,   0,  <span class="keyword">true</span>));
            mTestCases.push_back(TestCase(-1,   -1, <span class="keyword">false</span>));
            mTestCases.push_back(TestCase(0,    0,  <span class="keyword">false</span>));
            mTestCases.push_back(TestCase(1,    1,  <span class="keyword">false</span>));
            mTestCases.push_back(TestCase(2,    0,  <span class="keyword">true</span>));
        }
        
        <span class="keywordtype">float</span> evaluateFunction (Function* function)
        {
            <span class="keywordtype">float</span> fitness = 0;
            <span class="keywordflow">for</span> (TestCases::iterator it = mTestCases.begin(); it != mTestCases.end(); ++it)
            {
                Robot::singleton().setState(it-&gt;state);
                function-&gt;execute();
                <span class="keywordflow">if</span> (Robot::singleton().getMovement() == it-&gt;move &amp;&amp; Robot::singleton.isBeeping() == it-&gt;beep) { ++fitness; }
            }
            <span class="keywordflow">return</span> fitness;
        }
    };
</pre></div><p>Finally, we set everything in motion and watch the fireworks (or at least the console): </p>
<div class="fragment"><pre class="fragment">    <span class="comment">// Set up environment</span>
    RobotProblem problem;
    SimpleEnvironment environment = SimpleEnvironment(&amp;problem);
    environment.initializePopulation(100);
    <span class="comment">// Evolve solutions</span>
    environment.stepGenerations(1000);
    <span class="comment">// Print the best solution</span>
    Individual* individual = environment.getBestIndividual();
    Function* function = individual-&gt;getFunction();
    <span class="keywordtype">float</span> fitness = individual-&gt;getFitness();
    printf(<span class="stringliteral">&quot;Best individual:\n%s\nFitness: %f\n&quot;</span>, function-&gt;toString().c_str(), fitness);
</pre></div> </div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Tue Jun 19 2012 19:12:54 for Elf by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
